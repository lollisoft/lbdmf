Understanding the wrapper approach

The wxwrapper sample applications demonstrates the ability to write an 'application server' on the client
side. It provides the creation of menus and usage of them independent from the GUI api behind the wrapper.

The design of this functionality is event driven and fully dynamically.

The wrapper provides some functionality in a way, that I will describe in sample code:


// Initialize the system

UAP(lb_I_Module, mm, __FILE__, __LINE__)
mm = getModuleInstance();
mm->setModuleManager(mm.getPtr(), __FILE__, __LINE__);

// Set my own module manager
setModuleManager(mm.getPtr(), __FILE__, __LINE__);

// Get the event manager

REQUEST(mm.getPtr(), lb_I_EventManager, ev_manager)
ev_manager++;

// Get the dispatcher
UAP_REQUEST(mm.getPtr(), lb_I_Dispatcher, disp)
disp->setEventManager(ev_manager.getPtr());


// Init the GUI handler

if (wxGUI == NULL) {

      // Instanciate the GUI handler class that provides some basic handlers like
      // creating menus
      wxGUI = new lb_wxGUI();
      wxGUI->setModuleManager(mm.getPtr(), __FILE__, __LINE__);
      wxGUI->setDispatcher(*&disp);


      // Register Events, that I provide

      ev_manager->registerEvent("AddMenu", AddMenu);
      ev_manager->registerEvent("AddMenuBar", AddMenuBar);


      // The event manager registers symbolic events and assigns id's to it
      // The ID is stored in a local variable. This is not used but enables a speed up
      ev_manager->registerEvent("AddMenuEntry", AddMenuEntry);
      ev_manager->registerEvent("AddLabel", AddLabel);
      ev_manager->registerEvent("AddTextField", AddTextField);

      /**
       * Register any event handler from this instance by the wxGUI wrapper.
       */
      registerEventHandler(*&disp);
}

// Register the basic handlers in the dispatcher

lbErrCodes LB_STDCALL MyApp::registerEventHandler(lb_I_Dispatcher* disp) {
       _LOG << "Register event handler" LOG_;

        // We provide some menu manipulation
        disp->addEventHandlerFn(this, (lbEvHandler) &MyApp::lbEvHandler1, "AddMenu");
        disp->addEventHandlerFn(this, (lbEvHandler) &MyApp::lbEvHandler2, "AddMenuBar");
        disp->addEventHandlerFn(this, (lbEvHandler) &MyApp::lbEvHandler3, "AddMenuEntry");
        disp->addEventHandlerFn(this, (lbEvHandler) &MyApp::addButton, "AddButton");
        disp->addEventHandlerFn(this, (lbEvHandler) &MyApp::addLabel, "AddLabel");
        disp->addEventHandlerFn(this, (lbEvHandler) &MyApp::addTextField, "AddTextField");

        return ERR_NONE;
}

Now the event handlers are registered and can be used from the MetaApplication

In the OnInit function are some more steps to do, before the application can be used:

It creates a frame and stores the instance pointer in an interface pointer.

uk->queryInterface("lb_I_wxFrame", (void**) &frame, __FILE__, __LINE__);
frame_peer = frame->getPeer();

The frame_peer provides some handlers that are registered by calling

frame_peer->registerEvents(this);

After this it creates the event sources

err = frame_peer->createEventsource(this);

This is implemented like this:



//----------------------------------------------------------
// Make a menubar
wxMenu *file_menu = new wxMenu;

_LOG << "Create Build menu" LOG_
file_menu->Append(DYNAMIC_BUILDMENU, "&Build menu");
_LOG << "Create About menu" LOG_
file_menu->Append(DYNAMIC_ABOUT, "&About");
_LOG << "Create Exit menu" LOG_
file_menu->Append(DYNAMIC_QUIT, "E&xit");

  file_menu->Append(GUI->useEvent("DYNAMIC_ABOUT"), "&About");
  file_menu->Append(GUI->useEvent("DYNAMIC_QUIT"), "E&xit");

_LOG << "Create MenuBar" LOG_
menu_bar = new wxMenuBar;
menu_bar->Append(file_menu, "&File");


char ptr[20] = "";
sprintf(ptr, "%p", menu_bar);
_LOG << "Return a menu pointer: " << ptr LOG_

_LOG << "Appended File menu" LOG_

_LOG << "Set the menubar" LOG_
SetMenuBar(menu_bar);
_LOG << "Set up menubar" LOG_
//---------------------------------------------------------------



Now the wrapper loads an initializes a meta application:

UAP_REQUEST(mm.getPtr(), lb_I_MetaApplication, metaApp)
metaApp++;
if (metaApp != NULL) {
    metaApp->setGUI(wxGUI);

    /**
     * Try to register an event source for a basic information about the
     * application module as a first step.
     */
    metaApp->Initialize();
    _LOG << "Initialized the meta application" LOG_
}

It delegates the creation of basic functionality to lbMetaApplication.
More menus and handlers are created and are visible in the menu to be used.


The Application has been started up and can be used.





There is now the time to explain, why meta application.

The meta application is provided within the framework and therefore not the
real application.

You write the real application. To enable to run the real application I have defined
an environment variable that must contain the real application module (DLL/so).

This module is not registered in the XML file and must have a standard functor.
The following code how meta application loads this application module shows, how
it is implemented and how the functor is named:

You must define an environment variable for the application:
TARGET_APPLICATION=Application
This is the name of the DLL.

loadApplication(); is implemented this way:

lbErrCodes err = ERR_NONE;
// Get the DLL name
char* applicationName = getenv("TARGET_APPLICATION");

lb_I_Unknown* a;
// A standard functor for all applications
// Note: Name mangeling is based on my watcom compiler
// You must use _instanceOfApplication@16 or have a look into
// your application dll exports.
manager->makeInstance("_instanceOfApplication", applicationName, &a);

if (a == NULL) {
        _LOG << "ERROR: Application could not be loaded - either not found
or not configured." LOG_
        return ERR_NONE;
}
// Query an interface for an exsisting UAP variable
QI(a, lb_I_MetaApplication, app, __FILE__, __LINE__)

if (dispatcher.getPtr() == NULL) _LOG << "Error: dispatcher is NULL" LOG_

// The 'callback' to the GUI (In the test application not used)
app->setGUI(gui);

// Initialize the application, wich adds additional handlers and menu //
entries. app->Initialize();

if (dispatcher.getPtr() == NULL) _LOG << "Error: dispatcher has been set
to NULL" LOG_

return ERR_NONE;




Here are again some deep insides of the meta application:



The meta application is a very difficult design. There will be only 
two functions called. This is initialize and the function setGui.

There exists some interfaces for my event management.

lb_I_EventManager is used to register symbolic event names and
will return an event ID.

lbMetaApplication provides some basic handlers:

printf("Register some events\n");
eman->registerEvent("getBasicApplicationInfo", 
getBasicApplicationInfo);
eman->registerEvent("getMainModuleInfo", getMainModuleInfo);
eman->registerEvent("Button Test pressed", testPressed);
printf("Registered some events\n");

Then it registers the handlers by a dispatcher:

REQUEST(m, lb_I_Dispatcher, dispatcher)
dispatcher->setEventManager(eman.getPtr());

The member function registerEventHandler(dispatcher.getPtr()); then
registers the handlers:

lbErrCodes LB_STDCALL 
lb_MetaApplication::registerEventHandler(lb_I_Dispatcher* disp) {
 disp->addEventHandlerFn(this, (lbEvHandler) 		
 &lb_MetaApplication::lbEvHandler1, "getBasicApplicationInfo");
 disp->addEventHandlerFn(this, (lbEvHandler) 
 &lb_MetaApplication::lbEvHandler2, "getMainModuleInfo");
 disp->addEventHandlerFn(this, (lbEvHandler) 
 &lb_MetaApplication::lbButtonTestHandler, "Button Test pressed");
}

In this way the functionality of an application will be built up.

The test application does not provide any menu functionality. You 
should use the GUI application wxwrapper. (You need wxWindows)

