Programming with DMF



Introduction

DMF is designed to dynamically load instances from modules that are loaded at runtime. This
is similar to COM but it uses a XML repository.




First steps in using DMF

After you have setup the environment variables like the sample below you are able
to begin programming.


Setup environment sample:

(This is the root of your installed package) 
set DEVROOT= c:\lbDMF

(This is the XML file to be used)
set LBHOSTCFGFILE=%DEVROOT%\Projects\CPP\Test\Console\XML\lbXMLConfig.xml 

(This is the functor that instanciate the repository class)
set LBXMLFUNCTOR=_getlbDOMConfigInstance@16

(This is the XML repository module)
set LBXMLLIB=lbDOMConfig 

(This is the DLL/so module of the module manager)
set MODULELIB=lbModule set LBMODULEFUNCTOR=_getlb_ModuleInstance

- End of sample ----------------------------------------------------------------




Basic understanding of how the framework works


Each module uses a DLL/so module to load other modules. It provides the bootstrapping
code to get an instance of the module manager.

This bootstrapping code reads the environment variable MODULELIB to load the DLL/so
module. After it has loaded the module it calls the functor defined in LBMODULEFUNCTOR.

This code is implemented in getModuleInstance().

Before the function returns, the new instance loads the XML repository class which is
located in the LBXMLLIB environment variable. The functor is defined in LBXMLFUNCTOR.





In the application you need to initialize the system:

lb_I_Module* mm = getModuleInstance();

// Each instance must know, who the module manager is.
// This is implemented in the base class lb_I_Unknown 
// (implemented in the macro BEGIN_IMPLEMENT_LB_UNKNOWN in
// lbInterfaces.h in the interfaces directory)
mm->setModuleManager(mm, __FILE__, __LINE__);
// In this way, any class is capable to get instances like
// a lb_I_Container - wich is a skiplist.

// Now we have initialized our mm to be able to load instances




Sample of how to load an instance of a specfic class defined by the interface name:


// UAP is an lb_I_Unknown automatic pointer
// UAP_REQUEST too, but you get a ready loaded instance.
// In the example a database instance.
UAP_REQUEST(mm, lb_I_Database, database)

database->init();
database->connect("trainres", "dba", "trainres");

// UAP is an lb_I_Unknown automatic pointer
UAP(lb_I_Query, query, __FILE__, __LINE__)

// getQuery returns an instance for a query object connected
// to the database above
query = database->getQuery(0);





Now you know how to get objects.

There is a little difference, when loading objects inside a class:

(Define some UAP variables in the class definition)

class lb_MetaApplication :
public lb_I_MetaApplication,
public lb_I_EventHandler
{
public:
        lb_MetaApplication();
        virtual ~lb_MetaApplication();

        DECLARE_LB_UNKNOWN()

...

        DEBUG_UAP(lb_I_EventManager, eman, __FILE__, __LINE__)
        DEBUG_UAP(lb_I_Dispatcher, dispatcher, __FILE__, __LINE__)
        UAP(lb_I_MetaApplication, app, __FILE__, __LINE__)
};

Then get the instance for that interface. Note: you can implement 
multiple interfaces by inheriting.

In the implementation you then define:

BEGIN_IMPLEMENT_LB_UNKNOWN(lb_MetaApplication)
        ADD_INTERFACE(lb_I_MetaApplication)
        ADD_INTERFACE(...)
END_IMPLEMENT_LB_UNKNOWN()

This implements the basic functionality of each Unknown interface. 
You can then define multiple interfaces known by this class.

To load an instance, you have two ways to do it
First:

// Manager is defined in lb_I_Unknown's macro definition
// DECLARE_LB_UNKNOWN()
lb_I_Module* m = *&manager;
printf("Get an event manager\n");
REQUEST(m, lb_I_EventManager, eman)

Or you use this code:

REQUEST(manager.getPtr(), lb_I_EventManager, eman)

This is the principal way how to get instances.
